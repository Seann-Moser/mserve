// noinspection JSUnusedGlobalSymbols, DuplicateCode

/**
 * @typedef {Object} {{.Name}}Client
 * {{range .Endpoints}}
 * @property {({{jsParams .}}) => Promise<any>} {{.FunctionName}} - Calls {{.Method}} {{.Path}}
 * {{end}}
 */
import { defineNuxtPlugin, useRuntimeConfig } from '#app'

// --- Generated Request Body Classes ---
{{range .Endpoints}}{{if .HasBody}}
/**
 * Class representing the request body for {{.FunctionName}}
 */
export class {{.FunctionName}}Request {
  // Declare properties based on body schema
  {{range $prop := .RequestBodySchema.Properties}}
  /**
   * {{with $prop.Description}}{{.}}{{else}}{{$prop.Name}}{{end}}
   * @type {{jsDocType $prop.Schema}}
   */
  {{$prop.Name}};
  {{end}}

  /**
   * Create a new {{.FunctionName}}Request
   * @param {Partial<{{.FunctionName}}Request>} init - Initial values for fields
   */
  constructor(init = {}) {
    Object.assign(this, init)
  }

  /**
   * Serialize this instance to JSON for API calls
   * @returns {Object}
   */
  toJSON() {
    return { ...this }
  }
}
{{end}}{{end}}

export default defineNuxtPlugin((nuxtApp) => {
  const config = useRuntimeConfig()
  const baseURL = config.public.generated{{.Name}}BaseUrl || 'http://localhost:3000'

  /**
   * {{.Name}}Client Class
   */
  class {{.Name}}Client {
    constructor(baseURL, globalOptions = {}) {
      this.baseURL = baseURL
      this.globalOptions = globalOptions
    }

    _fetch(urlPath, fetchOptions) {
      const fullUrl = new URL(urlPath, this.baseURL).toString();

      return fetch(fullUrl, {
        ...this.globalOptions.fetchOptions,
        ...fetchOptions,
        headers: {
          ...(fetchOptions.body ? { 'Content-Type': 'application/json' } : {}),
          ...this.globalOptions.headers,
          ...fetchOptions.headers,
        },
      })
      // first, check for HTTP errors
      .then(response => {
        if (!response.ok) {
          const contentType = response.headers.get('content-type') || '';
          if (contentType.includes('application/json')) {
            return response.json()
              .catch(() => ({}))
              .then(errData => {
                throw new Error(errData.message || response.statusText || `API request failed with status ${response.status}`);
              });
          }
          return response.text()
            .then(text => {
              throw new Error(text || response.statusText || `API request failed with status ${response.status}`);
            });
        }
        return response;
      })
      // parse the successful response
      .then(response => {
        const contentType = response.headers.get('content-type') || '';
        return contentType.includes('application/json')
          ? response.json()
          : response.text();
      })
      // catch & rethrow (after logging)
      .catch(error => {
        console.error('API Error:', error);
        return Promise.reject(error);
      });
    }


    {{range .Endpoints}}
    /**
     * Calls {{.Method}} {{.Path}}
     {{with .PathParams}}{{range .}}
     * @param {{"{"}} {{jsDocType .Schema}} {{"}"}} {{.Name}} - Path parameter '{{.Name}}'
     {{end}}{{end}}{{with .QueryParams}}{{range .}}
     * @param {{"{"}} {{jsDocType .Schema}} {{"}"}} [{{.Name}}] - Query parameter '{{.Name}}'
     {{end}}{{end}}{{with .HeaderParams}}{{range .}}
     * @param {{"{"}} {{jsDocType .Schema}} {{"}"}} [{{.Name}}] - Header parameter '{{.Name}}'
     {{end}}{{end}}
     {{if .HasBody}}* @param {{"{"}} {{.FunctionName}}Request {{"}"}} body - Request body instance
     {{end}}
     * @returns {Promise<any>}
     */
    {{.FunctionName}}({{jsParams .}}) {
      let path = {{interpolatePath .Path .PathParams}}
      const urlParams = new URLSearchParams()
      {{queryParamsAppends .QueryParams}}
      {{with .PathParams}}{{range .}}urlParams.set("{{.Name}}",{{.Name}})
      {{end}}{{end}}

      if (urlParams.toString()) {
        path += `?${urlParams.toString()}`
      }
      const fetchOptions = {
        method: '{{.Method}}',
        headers: {{headersObject .HeaderParams}},
        {{if .HasBody}}body: JSON.stringify(body.toJSON()),{{end}}
      }
      return this._fetch(path, fetchOptions)
    }
    {{end}}
  }

  // Provide the API client as ${{.ApiName}}
  nuxtApp.provide('{{.ApiName}}', new {{.Name}}Client(baseURL, {
    fetchOptions: {},
    headers: {},
  }))
})
